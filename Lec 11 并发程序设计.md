# Lec 11 并发程序设计

## 基础

### 并发

+ 顺序程序设计

	- 顺序性
	
	- 封闭性
	
	- 确定性
	
	- 可再现性
	
+ 进程的并发性

	- 并发进程的无关性是进程的执行与时间无关的一个充分条件,又称为Bernstein条件

+ 资源竞争

	- 死锁
	
	- 饥饿

### 临界区管理

+ 进程的互斥

	- 只有一个进程可以访问资源
	
+ 临界区调度原则(Dijkstra)
	
	- 一次至多一个进程能够进入临界区内进行
	
	- 如果已有进程在临界区,其他进程应该等待
	
	- 进入临界区内的进程应该在有限时间内退出
	
+ 实现临界区管理的硬件设施

	- 关中断

	- 测试并建立指令
	
	- 对换指令

### 信号量与PV操作

+ 信号量(semaphore)与PV操作

	> 设s为一个记录型数据结构,一个分量为整型量value,另一个为信号量队列queue
	
	+ P(s):将信号量s减去l,若结果小于0,则调用P(s)的进程被置成等待信号量s的状态
		
	+ V(s):将信号量s加1,若结果不大于0,则释放(唤醒)一个等待信号量s的进程,使其转换为就绪态

	+ 若信号量s为正值,则该值等于在封锁进程之前对信号量s可施行的P操作次数
		
	+ 若信号量s为负值,则其绝对值等于登记排列在该信号量s队列之中等待的进程个数

	+ P操作意味着请求一个资源,V操作意味着释放一个资源。在一定条件下,P操作代表阻塞进程操作,而V操作代表唤醒被阻塞进程的操作
	
### 经典问题

+ 互斥问题

	- 飞机票问题
	
	- 哲学家就餐问题
	
+ 同步问题

	- 生产者消费者问题
	
	- 苹果桔子问题
	
### 管程

+ 目的

	- 把分散在各进程中的临界区集中起来进行管理
	
	- 防止进程有意或无意的违法同步操作
	
	- 便于用高级语言来书写程序
	
+ 属性

	- 共享性

	- 安全性

	- 互斥性

+ 管程的形式(Slides: p80)

	- wait():阻塞调用进程并释放管程,直到另一个进程在该条件变量上执行signal()

	- signal():如果存在其他进程由于对条件变量执行wait()而被阻塞,便释放之;如果没有进程在等待,那么,信号不被保存

+ **Hoare管程**

### 进程通信

+ 管道和套接字

## Linux进程通信实例

### 信号

> 对中断的模拟

+ 信号事件来源
	
	- 硬件来源
	
		+ 硬件操作:Ctrl+C
		
		+ 硬件故障
		
	- 软件来源
	
		+ 非法运算
		
		+ 函数

+ 生命周期:诞生,注册,传递,注销

+ 信号挂起

	> 信号可以保留不可预知的挂起时间
	
	+ 挂起信号队列
	
		- 整个线程组发送信号(共享挂起信号队列)
		
		- 向特定进程发送信号(私有挂起信号队列)

+ 进程对信号的响应方式

	- 忽略信号
	
	- 缺省操作
	
	- 捕获信号
	
### 管道通信

+ 管道

	- 又称匿名管道
	
	- 半双工
	
	- 只能用于具有亲缘关系的进程之间,如父子进程或兄弟进程之间
	
+ 匿名管道

+ FIFO(有名管道)

### 信号量

> 信号量是具有整数值的对象,表示可用资源的数量

+ IPC信号量
	
	- 申请资源时减1

### Socket

+ TCP

+ UDP

+ 套接字

	- 流套接字(SOCK_STREAM)
	
	- 数据报套接字(SOCK_DGRAM)
	
	- 原始套接字(SOCK_RAW)
	